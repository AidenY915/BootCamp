1. 프레임워크(Framework) 란?
	일관된 방식으로 프로그래밍을 하기 위해 정의된 구조나 틀
2. 자바에서 말하는 프레임워크? 
3. 자료구조(Data Structures)? 데이터를 효율적으로 사용하기 위해 데이터를 저장하는 다양한 구조
4. 알고리즘(Algorithms)	특정 상황의 문제를 해결하기 위한 일반적인 방법
5. 자료구조에서 정형화하고 있는 데이터의 저장방식 예. 

7. 컬렉션? 컬렉션은 다양한 자료구조를 일관된 방식으로 통제하기 위해 있는 프레임 워크.

8. 컬렉션 프레임 워크의 인터페이스 구조

	Collection<E>					Map<K,V>
		^
		|

 --------------------------------
 |		|		|	

Set<E>		List<E>		Queue<E>

	

9. 컬렉션이 프레임워크인 이유?
 인터페이스를 기반으로 구현이 되어 같은 기능들이 오버라이딩을 통해 같은 이름의 메소드들로 처리가 되어 메소드가 내부적으로 어떻게 구현되어 있는지 알지 못하더라도 일관된 방법만 알면 사용할 수 있기 때문이다.
10. List<E> 인터페이스와 이를 구현하는 제네릭 클래스는?
 ArrayList<E> LinkedList<E>
11. List<E> 인터페이스를 구현하는 제네릭 클래스들이 갖는 두 가지 특성은?
 저장 순서 유지, 중복 저장 가능

15. ArrayList<E>의 특징
 인덱싱이 가능해서 특정 원소로의 접근(참조)이 매우 빠르다.
 내부적으로 배열로 구현되어 있기 때문에 기존의 capacity를 초과할 경우 재할당의 시간 소요가 크다.
17. LinkedList<E> 특징
 중간의 원소를 삭제하거나 중간에 원소를 삽입 시 다른 원소들을 좌우로 밀어줄 필요가 없어. 빠른 시간 안에 처리가능하다.
 
18. 문제 22-2 [ArrayList<E> vs. LinkedList<E>]
아래에서 제시하는 상황에 적절한 자료구조를 선택해 보자. ArrayList<E>와 LinkedList<E> 둘 중 하나를 선택하면 된다.

* 상황1 
저장하게 되는 데이터의 수가 대략적으로 예측 가능하며, 빈번한 데이터의 참조가 일어나는 상황에서 유용하게 사용할 수 있는 컬렉션 클래스는 무엇인가? ArrayList
* 상황2
저장하게 되는 데이터의 수가 예측 불가응하며, 빈번한 데이터의 저장 및 삭제가 일어나는 상황에서 유용하게 사용할 수 있는 컬렉션 클래스는 무엇인가? LinkedList

19. LinkedList를 이용해 “First”, “Second”, “Third”, “Fourth”를 추가하고
반복자를 이용하며 출력하면서
“Third”를 삭제하자.
그리고 다시 반복자를 이용하여 출력하자.(반복자가 참조하는 것을 처음으로 옮길려면?)
반복자를 다시 생성해야 한다.(반복자는 일회용)

22. Iterable<E> 인터페이스
 	Collection이 상속하는 인터페이스로 유일한 멤버로 iterator() 즉, 반복자를 생성하기 위한 인터페이스이다.
23. 반복자의 의미
	여러 형태의 자료구조들을 동일한 방법으로 순회하기 위한 것


26. List<E> 인터페이스를 구현하는 클래스들과 Set<E> 인터페이스를 구현하는 클래스들의 차이점.
Set을 구현하는 클래스들은 저장 순서를 유지할 수 없고, 중복 저장이 불가능하다.
탐색이 대체적으로 빠르다.
HashSet은 hashcode를 이용해 굉장히 빠른 탐색을 하며, TreeSet 역시 선형 탐색에 비하면 매우 빠른 O(logn)의 탐색을 한다.
TreeSet의 경우 이진탐색트리중 하나인 AVL로 구현되어 있어. 삽입과 정렬이 같이 일어난다.


28. HashSet<E> 클래스가 (Object.hashCode())메소드의 호출결과와 (Object.equals())메소드의 호출결과를 가지고 동등비교

29. Hash<E> 클래스는 해시 알고리즘을 적용하여 데이터를 저장하고 검색한다. 그럼 그 방식을 어떠한 방법으로 진행하나?
hashCode()를 통해 인덱싱 후에 같은 hashCode를 가진 원소들 끼리 equals()를 통해 비교한다.


문제33 iterator 메소드가 반환하는 반복자는 정렬된 데이터를 (순방향)으로 참조한다.

문제34 정렬의 기준을 프로그래머가 직접 정의할 때 쓰는 Interface는? Comparable<>

문제35. 위의 (Comparable<>) 인터페이스의 compareTo 메소드는 어떤 내용을 근거로 정의되어야 하나? 인스턴스 메소드로서 자신이 앞에 와야하는 경우 음수를, 자신이 뒤로 가야하는 경우는 양수를, 서로 정렬 순서가 같을 경우는 0을 리턴해야 한다.

문제40. 오름차순의 반복자를 반환하는 iterator. 그럼 내림차순의 반복자를 반환하는 메소드는?
		descendingIterator

문제41. TreeSet<String> 인스턴스! 사전편찬 순서 말고, 길이 순으로 문자열을 정렬해라.
이런한 유형의 요구를 위해 정의된 것이 (Comparator)인터페이스이다.

-----------------------------------------------------------------------------------------------

문제43. TreeSet<E>를 이용하여 문제42에 있는 내용을 역순으로 출력되도록 예제를 변경해 보자. 단 StrLenComparator 클래스는 변경되면 안된다.(API 참조)
TreeSet<E> 클래스에 정의되어 있는 descendingIterator라는 메소드도 iterator 메소드와 마찬가지로 ‘반복자’를 반환한다. 단 iterator 메소드는 오름차순으로 검색하는 ‘반복자’를 반환하는 반면, descendingIterator는 내림차순으로 검색하는 ‘반복자’를 반환한다. 따라서 다음의 코드를 삽입하면 내림차순으로 출력되는 문자열을 확인할 수 있다.
문제44. (	)를 구현하는 컬렉션 클래스들이 value만 저장하는 구조였다면,  (Map)를 구현하는 컬렉션 클래스들은 value를 저장할 때, 이를 찾는데 사용되는 key를 함께 저장하는 구조이다.
문제45.  Map<K, V> 인터페이스를 구현하는 대표적인 클래스로 HashMap<K, V>와 TreeMap<K, V>가 정의되어 있다.
문제46. HashMap을 이용하여
3, "나삼번"
5, "윤오번"
8, "박팔번"
을 입력하고, 각각을 출력한 후에
5번을 삭제하고, 5번을 출력해보자.

문제47. Hash<K, V>를 구현하는 컬렉션 클래스들의 특징. 검색이 매우 빠르다.
문제48. navigableKeySet 메소드가 호출되면, 인터페이스 (NavigableSet)를 구현하는 인스턴스가(인스턴스의 참조 값이) 반환된다.
(NavigableSet) 인터페이스는 (Set<E>) 인터페이스를 상속한다. 즉 navigableKeySet 메소드가 반환하는 인스턴스를 대상으로 반복자를 얻기 위해서 iterator 메소드의 호출이 가능하다. 그리고 이렇게 해서 얻은 반복자로, 저장된 모든 key에 접근이 가능하다.
TreeMap<K, V>의 전체 데이터 검색
TreeMap<K, V>는 Collection<E>가 아닌 (Map)를 구현하는 컬렉션 클래스이니, 저장되어 있는 전체 데이터를 검색하는 방식에 차이가 있음은 당연한 일이다. 그리고 참으로 재미있는 것은 TreeMap<K, V>에 저장된 전체 데이터의 참조 과정에서 호출한 navigableKeySet 메소드가 반환하는 인스턴스가 Set<E> 인터페이스를 구현한다는 사실이다. key는 중복이 불가능하기 때문에 ‘집합’의 성격을 띤다. 때문에 이러한 key를 저장하는 인스턴스는 Set<E> 인터페이스를 구현하고 있는 것이다.

문제49. TreeMap을 이용하여
1, “data1”
3. “data3”
5, “data5”
2, “data2”
4, “data4”
을 저장하고
모든 데이터를 오름차순 출력
모든 데이터를 내림차순 출력을 하시오.

* 참고
ArrayList<E>

위에 코드에 사용된 'E'는 요소를 뜻하는 'Element'의 약자로 'E'대신 어떤 다른 문자를 사용해도 상관없지만 소스코드 내에서 같은 문자를 일관되게 해용해야 한다. 이는 마치 메서드의 매개변수 이름을 다르게 해도 메서드 내에서만 같은 이름을 사용하면 문제 없는 것과 같다.
'E'는 Object 타입이다.